# Grapevine
#### Video Demo:  https://youtu.be/Sj7k2BYv5Dw
#### Description:

Grapevine is my CS50 Project. It is a forums website where one can register and log into an account and post in one of many different sections, and then reply to one of those threads. This took me about a month to create, and I am excited to show it off.

We will be looking at our logic first. app.py and helpers.py both contain some crucial functions, so there's a lot to unpack. In app.py, I implemented register and login functions. These are the same functions that I made for pset9, Finance, and what they do is take an input from a form, validate and make sure it's a unique username and that the password is correct, and then fill in an entry in a SQL database. Next, we have our sections which just render a page showing all of the threads in a certain section. Threads are tagged with a section id, so all posts in General are tagged with id 0, all posts in gaming id 1, and so on. When we go into a section, it renders all of the posts with that id. Next, we have the view_post function. This gets the id of the post from a rather convoluted method where I used buttons and jinja variables to set the name of the button to the id, and then see which button you clicked in view_post. Anyway, it queries the database for the information for that id, as well as additional information such as title and username, and passes that to render_template. Also, it loops through the replies and passes those on as well. We also have compose, which takes an input from a form, checks to make sure no fields are empty, and then inserts that into a database and renders the post. This is where things get a bit tricky. I intend to have 3 different types of posts: posting threads, replies, and (in the future) direct messages. I have a big post function in helpers.py which can handle all three, but compose only deals with threads. After that is reply, which was one of the hardest functions to implement. Reply is split into 2 functions, reply, in app.py, and compose_reply, in helpers.py. The problem with replying is that there are multiple function calls required: one to get the id of the post you will be replying to, and one for the actual reply information like the content. We declare global variables to store the post id, and then pass that information to compose_reply where we actually insert it into the database.

Now for our helpers.py functions. Login_required and apology are both from pset9 as well, and I credited cs50 as well as the library makers for them. Apology returns an error screen while login_required makes a function decorator, making it so that if a user doesn't have a session they are redirected to the login page. I use this on all of my post functions like compose and reply. My first function here was post, which has 2 cases: a thread and a reply. Either way, an entry is inserted into the posts table in forum.db containing the content, user id, section id and type. When the type is a thread, it inserts the other information required such as the amount of replies on the thread, which is 0 when initially posted, and the title. It also then uses code from viewpost earlier and renders the post with all of its information. However, when it's a reply, we insert into the replies database the thread id the reply is attached to. We then display the post, using the same code as viewpost. Next, we have view_section. This takes in a section id as a parameter and queries the database for all of the posts with that section id. It then renders the section, creating a form with buttons to go to each thread. I also have a very brute force timezone adjuster, as I could not understand the documentation of datetime's timezones. Lastly, we have compose_reply, which takes in the content, username, and post id of a reply, validates the content to make sure it's not empty, and then calls post to insert the information.

Let's look at the database, forum.db. Forum.db is comprised of 4 tables, users, posts, threads, and replies. Users contains 6 columns, those being the user id, name, password, join date, positive reactions, and negative reactions. The user id is the autoincrementing primary key, and the names have to be unique. Posts is a table containing the elements in common between threads and replies: the user who posted it, the id of the post, the positive or negative reactions, the section, the timestamp, and the content of the post. Replies and threads both have the distinct data needed for each type of post. The replies table has the thread id the post is attached to, the post id linking it to the posts table, and the position of it in its thread. That sounded vague, so think of it like this: the first id, the thread id, is to know which post to show the reply on. The post id links it back to posts where we can see who wrote it and what the content is. The last id shows where to put it, first, second, or last in the reply section. The threads table has the title and the thread id, which is how those get ordered in a specific section.

Now let's go to all of the HTML. I used Bootstrap for almost all of the design except for my thread buttons. Some of the more important templates include compose, threads, post, and reply. Compose.html has a form submitting to /compose via POST, and it takes 2 inputs: a title and the content. Threads has a form at the top with the post button. This goes to /compose and renders the compose.html template previously discussed. The name of this button is the section id, and that is transferred to /compose. The actual posts are after this. It is a Jinja for loop that loops through the threads in that section and creates a form submitting to /post with that post id. Each thread title is a submit button, so when you click on it the post id of it is given over to /post. Post.html renders a template and takes in the information of a post and replies, using a for loop to render the replies. Lastly, reply.html has a form submitting to /reply. It takes the input of a reply and then returns that.

Alright, that's all of the code! Even though my functions could be a bit less redundant if I had had a better plan, I am still proud with how this turned out.